#include <dlfcn.h>

// FIXME:  This .h file could be auto-generated by a Python routine,
//         or at least by a macro, using the FOREACH trick of DMTCP.

// We initialize the fnc ptr inside initialize_pthread_simulator()
typeof(&pthread_create) pthread_create_ptr;
#define __real_pthread_create (*pthread_create_ptr)
typeof(&pthread_exit) pthread_exit_ptr;
#define __real_pthread_exit (*pthread_exit_ptr)
typeof(&pthread_join) pthread_join_ptr;
#define __real_pthread_join (*pthread_join_ptr)
typeof(&pthread_mutex_init) pthread_mutex_init_ptr;
#define __real_pthread_mutex_init (*pthread_mutex_init_ptr)
typeof(&pthread_mutex_lock) pthread_mutex_lock_ptr;
#define __real_pthread_mutex_lock (*pthread_mutex_lock_ptr)
typeof(&pthread_mutex_unlock) pthread_mutex_unlock_ptr;
#define __real_pthread_mutex_unlock (*pthread_mutex_unlock_ptr)
typeof(&sem_init) sem_init_ptr;
#define __real_sem_init (*sem_init_ptr)
typeof(&sem_wait) sem_wait_ptr;
#define __real_sem_wait (*sem_wait_ptr)
typeof(&sem_post) sem_post_ptr;
#define __real_sem_post (*sem_post_ptr)

static void initialize_pthread_wrappers() {
  pthread_create_ptr = dlsym(RTLD_NEXT, "pthread_create");
  pthread_exit_ptr = dlsym(RTLD_NEXT, "pthread_exit");
  pthread_join_ptr = dlsym(RTLD_NEXT, "pthread_join");
  pthread_mutex_init_ptr = dlsym(RTLD_NEXT, "pthread_mutex_init");
  pthread_mutex_lock_ptr = dlsym(RTLD_NEXT, "pthread_mutex_lock");
  pthread_mutex_unlock_ptr = dlsym(RTLD_NEXT, "pthread_mutex_unlock");
  sem_init_ptr = dlsym(RTLD_NEXT, "sem_init");
  sem_wait_ptr = dlsym(RTLD_NEXT, "sem_wait");
  sem_post_ptr = dlsym(RTLD_NEXT, "sem_post");
}
